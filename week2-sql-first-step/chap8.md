## 데이터베이스 설계

---

### 1. 데이터베이스 설계

- 데이터베이스 설계
  - 데이터 스키마 내 테이블, 인덱스, 뷰 등 데이터베이스 객체를 정의하는 것
  - 주된 내용 : 테이블 이름, 열, 자료형 결정하는 것


- **논리명** & **물리명**
  - ex ) 테이블 정의서 사례
  
  | 열명 | 자료형 | NULL | 기본값 | 비고 |
        | --- | --- | --- | --- | --- |
        | 상품코드 | CHAR(4) | No |  |  |
        | 상품명 | VARCHAR(30) | Yes |  |  |
        | 가격 | INTEGER | Yes |  |  |
  
    - 논리명 : 테이블의 설계 상 이름
    - 물리명 : CREATE TABLE에 지정하는 이름
        - 길이 제한이나 공백 문자 불가 등 시스템 제약이 있음
        - 물리명만으로 의미 전달이 안되는 경우도 많아 논리명이 필요 해짐
    - 위같은 특징으로 아래처럼 논리명 기입 항목을 함께 기입 하기도 함

        | 열명 | 논리명 | 자료형 | NULL | 기본값 | 비고 |
        | --- | --- | --- | --- | --- | --- |
        | item_code | 상품코드 | CHAR(4) | No |  |  |
        | item_name | 상품명 | VARCHAR(30) | Yes |  |  |
        | price | 가격 | INTEGER | Yes |  |  |
        - 아니면 논리명 컬럼을 두지 않고 비고에 쓰기도 함


- **자료형**
  - 컬럼에 데이터를 ‘1,2,3 중 하나’ 를 받거나 ‘yes 또는 no’ 만 받는 등의 조건이 포함될 경우

    ⇒ 데이터 정합성이 중요한 부분에는 `CHECK` 제약을 적극적으로 걸자

      ```sql
      CREATE TABLE Customer (
          ID int NOT NULL,
          LastName varchar(255) NOT NULL,
          FirstName varchar(255),
          Age int,
          CHECK (Age>=18) // 나이를 18살 이상만 들어오도록 함
      );
      ```

  - 만약 DBMS에서 데이터 적합성을 체크할 수 있다면 DB에 맡겨버리는 편이 가장 확실하고 편리함
  - 위처럼 조건 제약 사항이 붙을 경우 테이블 정의서 비고란에 쓰는 것이 좋음


- **고정길이 & 가변길이**
  - 저장할 데이터를 고려해 결정하자
  - ex )
    - 데이터 자리수가 이미 정해져 있는 제조번호 ⇒ 고정길이
    - 자주 입력 되지도 않지만 문자열 길이 변동 폭이 큰 비고란 ⇒ 가변길이
  - **LOB (Large Object)**
    - DB 열에 저장할 수 있는 크키는 꽤 작음 (`VARCHAR` 형으로 지정 가능한 최대 크기는 수천 바이트)

      ⇒ 좀 큰 파일 저장하려고 하면 금세 용량 넘어감

      ⇒ 따라서 LOB 사용해 큰 데이터를 다룸

    - 인덱스를 지정할 수 없다는 단점 존재


- **기본키**
  - DB에서는 기본 키 생성할 때 자동증가 열 생성으로 `AUTO_INCREMENT` 사용하면 됨
    - `AUTO_INCREMENT` 사용하려면 해당 열을 `PRIMARY_KEY`  또는 `UNIQUE` 로 유일성을 지정해줘야 함

### 2. ER다이어그램

- Entity Relationship으로, 개체 간 관계를 표현한 것
- Entity : 개체는 테이블 또는 뷰
  - 열 이름은 주로 논리명으로 표기
- 개체와 개체 간 연계되는 경우는 선으로 이어서 표시
- ER다이어그램의 연계는 DB에서 외래키 참조 제약으로 지정됨
  - 데이터 정합성이 엄격히 관리되므로 번거로워서 이를 채용하지 않는 시스템도 있음
- 설계 상으로만 이렇게 연관있다 정도로 표현함

## 정규화

---

### 정규화

- 대충 만들어진 데이터를 정규화 해서 데이터베이스로 만들어보자

    | 주문번호 | 날짜 | 성명 | 연락처 | 주문상품 |
    | --- | --- | --- | --- | --- |
    | 1 | 1/1 | 박준용 | 010-XXXX | 0001 A 1개, 0002 B 10개 |
    | 2 | 2/1 | 김재진 | 010-XXXX | 0001 A 2개, 0002 B 3개 |
    | 3 | 2/5 | 박준용 | 010-XXXX | 0001 A 3개, 0003 C 1개 |

### 제 1 정규형 (1NF)

1. 반복되는 데이터를 행 방향으로 늘리고

    | 주문번호 | 날짜 | 성명 | 주문상품 |
    | --- | --- | --- | --- |
    | 1 | 1/1 | 박준용 | 0001 A 1개 |
    | 1 | 1/1 | 박준용 |  0002 B 10개 |
    | 2 | 2/1 | 김재진 | 0001 A 2개 |
    | 2 | 2/1 | 김재진 | 0002 B 3개 |
    | 3 | 2/5 | 박준용 | 0001 A 3개 |
    | 3 | 2/5 | 박준용 | 0003 C 1개 |
2. 테이블을 분할하고 기본키를 지정
   - 주문 테이블

     | 주문번호 | 날짜 | 성명 |
     | --- | --- | --- |
     | 1 | 1/1 | 박준용 |
     | 2 | 2/1 | 김재진 |
     | 3 | 2/5 | 박준용 |
   
   - 주문 상품 테이블

       | 주문번호 | 상품 코드 | 상품 명 | 개수 |
       | --- | --- | --- | --- |
       | 1 | 0001  | A | 1 |
       | 1 | 0002 | B | 10 |
       | 2 | 0001  | A | 2 |
       | 2 | 0002 | B | 3 |
       | 3 | 0001  | A | 3 |
       | 3 | 0003 | C | 1 |
- 장점
  - 데이터 중복이 줄어들어 데이터 무결성 유지 도움
  - 데이터 수정, 삭제, 삽입에 이상 문제 방지
  - 데이터 구조 단순

### 제 2 정규형 (2NF)

- 제1 정규화를 진행한 테이블에 대해 **완전 함수 종속**을 만족하도록 테이블을 분해하는 것
  - 기본키에 중복을 제거하는 것
  - **완전 함수 종속** : 기본키의 부분 집합이 다른 테이블의 결정자가 되어선 안된다는 사항
- ex ) 기본키에 의해 특정되는 열과 아닌 열로 나눠 정규화 진행
- 주문 테이블

  | 주문번호 | 상품 코드 | 상품 명 | 개수 |
  | --- | --- | --- | --- |
  | 1 | 0001  | A | 1 |
  | 1 | 0002 | B | 10 |
  | 2 | 0001  | A | 2 |
  | 2 | 0002 | B | 3 |
  | 3 | 0001  | A | 3 |
  | 3 | 0003 | C | 1 |

- 주문 상품 테이블의 기본 키 : `주문번호 + 상품 코드` 로 (`상품명 + 개수`)를 구분함
  - 또한, 상품 코드가 상품명에 대한 기본키가 될 수 있음 → 완전 함수 종속 X


- 그래서 상품 코드 혼자서 기본키가 될 수 있는 테이블로 분리함
  - 상품 테이블
  
    | 상품 코드 | 상품명 |
    | --- | --- |
    | 0001 | A |
    | 0002 | B |
    | 0003 | C |
  - 변경된 주문 테이블

    | 주문번호 | 상품 코드 | 개수 |
    | --- | --- | --- |
    | 1 | 0001  | 1 |
    | 1 | 0002 | 10 |
    | 2 | 0001  | 2 |
    | 2 | 0002 | 3 |
    | 3 | 0001  | 3 |
    | 3 | 0003 | 1 |

### 제 3 정규형 (3NF)

- 제 2 정규화 된 테이블에서 이번엔 **기본 키 외의 부분**에서 중복 없는지 판단
  - **이행적 종속**을 없애도록 테이블을 분해해야 함
  - **이행적 종속** : 삼단논법이 성립되는 것 ( A→B && B→C ⇒ A→C )
  

- 주문 테이블

  | 주문번호 | 날짜 | 성명 | 연락처 |
  | --- | --- | --- | --- |
  | 1 | 1/1 | 박준용 | 010-1234-1234 |
  | 2 | 2/1 | 김재진 | 010-4321-4321 |
  | 3 | 2/5 | 박준용 | 010-1234-1234 |
- 현재 같은 사람이 반복돼서 나옴 → 이름 기준으로 연락처 특정이 가능

  ⇒ 그러니 성명과 연락처로 테이블을 나누자

    - 새로운 고객 테이블

      | 고객번호 | 이름 | 연락처 |
      | --- | --- | --- |
      | 1 | 박준용 | 010-1234-1234 |
      | 2 | 김재진 | 010-4321-4321 |

### 정규화 전, 후 테이블

- 정규화 전

  | 주문번호 | 날짜 | 성명 | 연락처 | 주문상품 |
  | --- | --- | --- | --- | --- |
  | 1 | 1/1 | 박준용 | 010-XXXX | 0001 A 1개, 0002 B 10개 |
  | 2 | 2/1 | 김재진 | 010-XXXX | 0001 A 2개, 0002 B 3개 |
  | 3 | 2/5 | 박준용 | 010-XXXX | 0001 A 3개, 0003 C 1개 |
- 제 3 정규화 후
  - 주문

  | 주문번호 | 날짜 | 고객번호 |
  | --- | --- | --- |
  | 1 | 1/1 | 1 |
  | 2 | 2/1 | 2 |
  | 3 | 2/5 | 1 |
- 고객

    | 고객번호 | 고객이름 | 연락처 |
    | --- | --- | --- |
    | 1 | 박준용 | 010-1234-1234 |
    | 2 | 김재진 | 010-4321-4321 |

- 주문상품
         
    | 주문번호 | 상품코드 | 개수 |
    | --- | --- | --- |
    | 1 | 0001 | 1 |
    | 1 | 0002 | 10 |
    | 2 | 0001 | 2 |
    | 2 | 0002 | 3 |
    | 3 | 0001 | 3 |
    | 3 | 0003 | 1 |

- 상품

    | 상품 코드 | 상품명 |
    | --- | --- |
    | 0001 | A |
    | 0002  | B |
    | 0003  | C |

### 정규화 목적

- 정규화는 중복하거나 반복되는 부분을 찾아내서 테이블을 분할하고 기본키를 작성해 사용하는 것이 기본 개념

  ⇒ ‘**하나의 데이터는 한 곳에 있어야 한다’**는 규칙에 근거

- 정규화 된 테이블
  - 데이터 하나에 대해 변경이 일어나면 한 군데만 수정하면 됨
- 정규화 되지 않은 테이블
  - 데이터 하나에 대해 변경이 일어나면 해당 데이터가 있는 곳을 모두 검색해서 사용해야 함
- 인덱스가 지정된 열의 데이터가 변경될 경우는 인덱스도 재구축 해야 함
- 기본키는 분할한 테이블끼리 연계하기 위해 작성한 내부적인 데이터

  ⇒ 변경 될 일은 거의 없음

  ⇒ 정규화 통해 인덱스 재구축 억제 가능


## 트랜잭션

---

### 트랜잭션

- A가 B로 5000원 계좌이체하는 예시일 때

```sql
UPDATE Account SET amount = amount - 5000 WHERE account_id = 'A';
UPDATE Account SET amount = amount + 5000 WHERE account_id = 'B';
```

- B의 계좌 총액에 +5000원을 하는 와중 에러가 발생할 경우 (2번 째 쿼리),

  ⇒ A의 계좌 금액을 다시 +5000원 해주는 쿼리를 날려야 함

  - 위 과정은 반드시 원자적으로 수행되어야 함 (둘 중 하나만 실행 되면 안됨)
- 위 상황을 쉽게 처리해줄 수 있는 것이 **트랜잭션**
- 트랜잭션 : 데이터베이스의 데이터가 변경될 때 원자적으로 처리할 수 있는 실행 단위

### 롤백과 커밋

- **rollback** : 에러가 발생했을 때, 실행 단위를 모두 원상태로 복구하는 것
- **commit** : 정상적으로 작동 했을 때, 실행 결과를 반영하는 것
  - MySQL 클라이언트는 데이터 변경에 대해 자동 커밋이 켜져 있음


- MySQL에서 명시적으로 트랜잭션 수행하기

    ```sql
    START TRANSACTION
    ```

  - 표준은 아님
    - PostgreSQL과 SQL Server는 `BEGIN TRANSACTION`
    - Oracle, DB2는 트랜잭션 시장 명령어 따로 없음


- 트랜잭션 내에서 실행한 명령 적용 후 종료

    ```sql
    COMMIT
    ```

  - 주로 실행 사항을 적용할 때 쓰지만, 에러 발생하고도 commit 하면 적용할 수 있음


- 트랜잭션 내에서 실행한 명령 파기 후 종료

    ```sql
    ROLLBACK
    ```

  - 주로 실행 사항을 파기할 때 쓰지만, 에러 발생하지 않아도 rollback 하면 파기할 수 있음


- 트랜잭션을 사용하면 위에서  있던 계좌이체 로직도 원자적으로 수행 가능함

    ```sql
    START TRANSACTION;
    	UPDATE Account SET amount = amount - 5000 WHERE account_id = 'A';
    	UPDATE Account SET amount = amount + 5000 WHERE account_id = 'B';
    COMMIT;
    ```
